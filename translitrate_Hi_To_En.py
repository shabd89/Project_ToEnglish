{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0b0eb6b4",
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import unicode_literals, division, absolute_import, print_function\n",
    "import six\n",
    "from builtins import zip\n",
    "from builtins import object\n",
    "\n",
    "\n",
    "#name of Hindi-Brahmic text.\n",
    "HINDI = 'hindi'\n",
    "\n",
    "#name of English-Roman Text.\n",
    "ENGLISH = 'en'\n",
    "\n",
    "SCHEMES = {}\n",
    "\n",
    "class Scheme(dict):\n",
    "\n",
    "    \"\"\"Represents all of the data associated with a given scheme. In addition\n",
    "    to storing whether or not a scheme is roman, :class:`Scheme` partitions\n",
    "    a scheme's characters into important functional groups.\n",
    "    :class:`Scheme` is just a subclass of :class:`dict`.\n",
    "    :param data: a :class:`dict` of initial values.\n",
    "    :param is_roman: `True` if the scheme is a romanization and `False`\n",
    "                     otherwise.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, data=None, is_roman=True):\n",
    "        super(Scheme, self).__init__(data or {})\n",
    "        self.is_roman = is_roman\n",
    "        \n",
    "class SchemeMap(object):\n",
    "\n",
    "    \"\"\"Maps one :class:`Scheme` to another. This class grabs the metadata and\n",
    "    character data required for :func:`transliterate`.\n",
    "    :param from_scheme: the source scheme\n",
    "    :param to_scheme: the destination scheme\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, from_scheme, to_scheme):\n",
    "        \"\"\"Create a mapping from `from_scheme` to `to_scheme`.\"\"\"\n",
    "        self.marks = {}\n",
    "        self.virama = {}\n",
    "\n",
    "        self.vowels = {}\n",
    "        self.consonants = {}\n",
    "        self.other = {}\n",
    "        self.from_roman = from_scheme.is_roman\n",
    "        self.to_roman = to_scheme.is_roman\n",
    "        self.longest = max(len(x) for g in from_scheme\n",
    "                           for x in from_scheme[g])\n",
    "\n",
    "        for group in from_scheme:\n",
    "            if group not in to_scheme:\n",
    "                continue\n",
    "            sub_map = {k: v for (k, v) in zip(from_scheme[group],\n",
    "                                              to_scheme[group])}\n",
    "            if group.endswith('marks'):\n",
    "                self.marks.update(sub_map)\n",
    "            elif group == 'virama':\n",
    "                self.virama = sub_map\n",
    "            else:\n",
    "                self.other.update(sub_map)\n",
    "                if group.endswith('consonants'):\n",
    "                    self.consonants.update(sub_map)\n",
    "                elif group.endswith('vowels'):\n",
    "                    self.vowels.update(sub_map)\n",
    "\n",
    "\n",
    "def _roman(data, scheme_map, **kw):\n",
    "    \"\"\"Transliterate `data` with the given `scheme_map`. This function is used\n",
    "    when the source scheme is a Roman scheme.\n",
    "    :param data: the data to transliterate\n",
    "    :param scheme_map: a dict that maps between characters in the old scheme\n",
    "                       and characters in the new scheme\n",
    "    \"\"\"\n",
    "    vowels = scheme_map.vowels\n",
    "    marks = scheme_map.marks\n",
    "    virama = scheme_map.virama\n",
    "    consonants = scheme_map.consonants\n",
    "    other = scheme_map.other\n",
    "    longest = scheme_map.longest\n",
    "    to_roman = scheme_map.to_roman\n",
    "\n",
    "    togglers = kw.pop('togglers', set())\n",
    "    suspend_on = kw.pop('suspend_on', set())\n",
    "    suspend_off = kw.pop('suspend_off', set())\n",
    "    if kw:\n",
    "        raise TypeError('Unexpected keyword argument %s' % list(kw.keys())[0])\n",
    "\n",
    "    buf = []\n",
    "    i = 0\n",
    "    had_consonant = found = False\n",
    "    len_data = len(data)\n",
    "    append = buf.append\n",
    "\n",
    "    # If true, don't transliterate. The toggle token is discarded.\n",
    "    toggled = False\n",
    "    # If true, don't transliterate. The suspend token is retained.\n",
    "    # `suspended` overrides `toggled`.\n",
    "    suspended = False\n",
    "\n",
    "    while i <= len_data:\n",
    "        # The longest token in the source scheme has length `longest`. Iterate\n",
    "        # over `data` while taking `longest` characters at a time. If we don`t\n",
    "        # find the character group in our scheme map, lop off a character and\n",
    "        # try again.\n",
    "        #\n",
    "        # If we've finished reading through `data`, then `token` will be empty\n",
    "        # and the loop below will be skipped.\n",
    "        token = data[i:i + longest]\n",
    "\n",
    "        while token:\n",
    "            if token in togglers:\n",
    "                toggled = not toggled\n",
    "                i += 2  # skip over the token\n",
    "                found = True  # force the token to fill up again\n",
    "                break\n",
    "\n",
    "            if token in suspend_on:\n",
    "                suspended = True\n",
    "            elif token in suspend_off:\n",
    "                suspended = False\n",
    "\n",
    "            if toggled or suspended:\n",
    "                token = token[:-1]\n",
    "                continue\n",
    "\n",
    "            # Catch the pattern CV, where C is a consonant and V is a vowel.\n",
    "            # V should be rendered as a vowel mark, a.k.a. a \"dependent\"\n",
    "            # vowel. But due to the nature of Brahmic scripts, 'a' is implicit\n",
    "            # and has no vowel mark. If we see 'a', add nothing.\n",
    "            if had_consonant and token in vowels:\n",
    "                mark = marks.get(token, '')\n",
    "                if mark:\n",
    "                    append(mark)\n",
    "                elif to_roman:\n",
    "                    append(vowels[token])\n",
    "                found = True\n",
    "\n",
    "            # Catch any other character, including consonants, punctuation,\n",
    "            # and regular vowels. Due to the implicit 'a', we must explicitly\n",
    "            # end any lingering consonants before we can handle the current\n",
    "            # token.\n",
    "            elif token in other:\n",
    "                if had_consonant:\n",
    "                    append(virama[''])\n",
    "                append(other[token])\n",
    "                found = True\n",
    "\n",
    "            if found:\n",
    "                had_consonant = token in consonants\n",
    "                i += len(token)\n",
    "                break\n",
    "            else:\n",
    "                token = token[:-1]\n",
    "\n",
    "        # We've exhausted the token; this must be some other character. Due to\n",
    "        # the implicit 'a', we must explicitly end any lingering consonants\n",
    "        # before we can handle the current token.\n",
    "        if not found:\n",
    "            if had_consonant:\n",
    "                append(virama[''])\n",
    "            if i < len_data:\n",
    "                append(data[i])\n",
    "                had_consonant = False\n",
    "            i += 1\n",
    "\n",
    "        found = False\n",
    "\n",
    "    return ''.join(buf)\n",
    "\n",
    "\n",
    "def _brahmic(data, scheme_map, **kw):\n",
    "    \"\"\"Transliterate `data` with the given `scheme_map`. This function is used\n",
    "    when the source scheme is a Brahmic scheme.\n",
    "    :param data: the data to transliterate\n",
    "    :param scheme_map: a dict that maps between characters in the old scheme\n",
    "                       and characters in the new scheme\n",
    "    \"\"\"\n",
    "    marks = scheme_map.marks\n",
    "    virama = scheme_map.virama\n",
    "    consonants = scheme_map.consonants\n",
    "    other = scheme_map.other\n",
    "    to_roman = scheme_map.to_roman\n",
    "\n",
    "    buf = []\n",
    "    had_consonant = False\n",
    "    append = buf.append\n",
    "    L1 = 'A'\n",
    "    for L in data:\n",
    "        print(L,len(L))\n",
    "        if L in marks:\n",
    "            append(marks[L])\n",
    "            print('marks')\n",
    "            print(marks[L])\n",
    "        elif L in virama:\n",
    "            append(virama[L])\n",
    "            print('virama')\n",
    "            print(virama[L])\n",
    "        else:\n",
    "            print('1',+ had_consonant)\n",
    "            #print(L1,len(L1))\n",
    "            if had_consonant and L != ' ':\n",
    "                append('A')\n",
    "                print('A')\n",
    "            append(other.get(L, L))\n",
    "            print(other.get(L, L))\n",
    "        had_consonant = to_roman and L in consonants\n",
    "        #L1 = L\n",
    "        print('2',+ had_consonant)\n",
    "        #print(L,L1)\n",
    "    print('3',+ had_consonant)\n",
    "    #if had_consonant:\n",
    "    #    append('A')\n",
    "    return ''.join(buf)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "def transliterate(data, _from=None, _to=None, scheme_map=None, **kw):\n",
    "    \"\"\"Transliterate `data` with the given parameters::\n",
    "        output = transliterate('idam adbhutam', HK, DEVANAGARI)\n",
    "    Each time the function is called, a new :class:`SchemeMap` is created\n",
    "    to map the input scheme to the output scheme. This operation is fast\n",
    "    enough for most use cases. But for higher performance, you can pass a\n",
    "    pre-computed :class:`SchemeMap` instead::\n",
    "        scheme_map = SchemeMap(SCHEMES[HK], SCHEMES[DEVANAGARI])\n",
    "        output = transliterate('idam adbhutam', scheme_map=scheme_map)\n",
    "    :param data: the data to transliterate\n",
    "    :param _from: the name of a source scheme\n",
    "    :param _to: the name of a destination scheme\n",
    "    :param scheme_map: the :class:`SchemeMap` to use. If specified, ignore\n",
    "                       `_from` and `_to`. If unspecified, create a\n",
    "                       :class:`SchemeMap` from `_from` to `_to`.\n",
    "    \"\"\"\n",
    "    if scheme_map is None:\n",
    "        from_scheme = SCHEMES[_from]\n",
    "        to_scheme = SCHEMES[_to]\n",
    "        scheme_map = SchemeMap(from_scheme, to_scheme)\n",
    "\n",
    "    options = {\n",
    "        'togglers': set(['##']),\n",
    "        'suspend_on': set('<'),\n",
    "        'suspend_off': set('>')\n",
    "    }\n",
    "    options.update(kw)\n",
    "\n",
    "    func = _roman if scheme_map.from_roman else _brahmic\n",
    "    return func(data, scheme_map, **options)\n",
    "\n",
    "\n",
    "def _setup():\n",
    "    \"\"\"Add a variety of default schemes.\"\"\"\n",
    "    s = six.text_type.split\n",
    "\n",
    "    SCHEMES.update({\n",
    "       HINDI: Scheme({\n",
    "            'vowels': s(\"\"\"अ आ इ ई उ ऊ ऋ ॠ ऌ ॡ ऍ ए ऐ ऑ ओ औ\"\"\"),\n",
    "            'marks': s(\"\"\"ा ि ी ु ू ृ ॄ ॢ ॣ े ै ो ौ\"\"\"),\n",
    "            'virama': s('्'),\n",
    "            'other': s('ं ः ँ कॉलोनी'),\n",
    "            'consonants': s(\"\"\"\n",
    "                            क ख ग घ ङ\n",
    "                            च छ ज झ ञ\n",
    "                            ट ठ ड ढ ण\n",
    "                            त थ द ध न\n",
    "                            प फ ब भ म\n",
    "                            य र ल व\n",
    "                            श ष स ह\n",
    "                            ळ क्ष ज्ञ त्र ब् श्\n",
    "                            \"\"\"),\n",
    "            'symbols': s(\"\"\"\n",
    "                       ॐ ऽ । ॥\n",
    "                       ० १ २ ३ ४ ५ ६ ७ ८ ९\n",
    "                       \"\"\")\n",
    "            }, is_roman=False),\n",
    "        ENGLISH: Scheme({\n",
    "            'vowels': s(\"\"\"A AA I EE U OO R RR LR LRR E E AI O O AU\"\"\"),\n",
    "            'marks': s(\"\"\"A I EE U OO R RR lR lRR E AI O AU\"\"\"),\n",
    "            'virama': [''],\n",
    "            'other': s('N H N COLONY'),\n",
    "            'consonants': s(\"\"\"\n",
    "                            K KHA G GH R\n",
    "                            CH CHH J JH N\n",
    "                            TT TTH DD DDH N\n",
    "                            T TH D DH N\n",
    "                            P PH B BH M\n",
    "                            Y R L V\n",
    "                            SH SH S H\n",
    "                            LL KSH GY TR B S\n",
    "                            \"\"\"),\n",
    "            'symbols': s(\"\"\"\n",
    "                       OM ' | ||\n",
    "                       0 1 2 3 4 5 6 7 8 9\n",
    "                       \"\"\")\n",
    "        })\n",
    "    })\n",
    "\n",
    "_setup()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f29016a",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
